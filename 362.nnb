{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "type CashFlow = {\r\n    cash: number,\r\n    annualInterestRate: number,\r\n    timeInYears:number,\r\n}\r\n\r\ntype Frequency = 'continuous' | 'semi' | 'quarter' | 'monthly' | 'annual'\r\n\r\nconst adjFactor: Record<Frequency, number> = {\r\n    semi: 2,\r\n    quarter: 4,\r\n    monthly: 12,\r\n    annual: 1,\r\n    continuous: 1,\r\n}\r\n\r\nfunction pv(cashFlows: CashFlow[], compoundFrequency: Frequency) {\r\n    return cashFlows.reduce((pv: number, cf: CashFlow) => {\r\n        \r\n        const adjustedInterestRate = cf.annualInterestRate * adjFactor[compoundFrequency];\r\n        const adjustedTime = cf.timeInYears * adjFactor[compoundFrequency];\r\n\r\n        const df = compoundFrequency === \"continuous\" ? \r\n                        Math.exp(-1 * adjustedInterestRate * adjustedTime) : \r\n                        Math.pow(1/(1+adjustedInterestRate), adjustedTime);\r\n\r\n        return pv + (cf.cash * df);\r\n    }, 0);\r\n}\r\n\r\nfunction fv(cashFlows: CashFlow[], compoundFrequency) {\r\n    return cashFlows.reduce((pv: number, cf: CashFlow) => {\r\n        \r\n        const adjustedInterestRate = cf.annualInterestRate * adjFactor[compoundFrequency];\r\n        const adjustedTime = cf.timeInYears * adjFactor[compoundFrequency];\r\n\r\n        const df = compoundFrequency === \"continuous\" ? \r\n                        Math.exp(adjustedInterestRate * adjustedTime) : \r\n                        Math.pow((1+adjustedInterestRate), adjustedTime);\r\n\r\n        return pv + (cf.cash * df);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * \r\n * @param spotRateHc 1 HomeCurrency: x ForeignCurrency (x is Param)\r\n */\r\nfunction forexForwardRate(spotRateHc: number, hcInterestRate: number, fcInterestRate: number, t: number) {\r\n    return (spotRateHc * Math.exp(fcInterestRate * t))/(Math.exp(hcInterestRate * t));\r\n}\r\n\r\n/**\r\n * \r\n * @param forwardRateHc 1 HomeCurrency: x ForeignCurrency (x is Param)\r\n */\r\nfunction forexSpotRate(forwardRateHc: number, hcInterestRate: number, fcInterestRate: number, t: number) {\r\n    return (forwardRateHc * Math.exp(hcInterestRate * t))/(Math.exp(fcInterestRate * t));\r\n}\r\n\r\nfunction futuresPrice(\r\n    spotPrice: number,\r\n    riskFreeRate: number,\r\n    timeInYears: number,\r\n    compoundType: Frequency,\r\n    storageCostsRate: number = 0,\r\n    dividendYield: number = 0,\r\n    convenienceYield: number = 0,\r\n    storageCostInAdvance: number = 0\r\n): number {\r\n    return fv([\r\n        {\r\n            cash: spotPrice + storageCostInAdvance,\r\n            annualInterestRate: riskFreeRate + storageCostsRate - dividendYield - convenienceYield,\r\n            timeInYears\r\n        }\r\n    ], compoundType)\r\n}\r\n\r\nfunction futuresValue(\r\n    contractedPrice: number,\r\n    currentPrice: number,\r\n    riskFreeRate: number,\r\n    timeInYears: number,\r\n    compoundType: Frequency,\r\n    position: 'long' | 'short',\r\n    contractSize: number = 1\r\n)  {\r\n    if (position === 'long') {\r\n        contractedPrice *= -1;\r\n        currentPrice *= -1;\r\n    }\r\n\r\n    return pv([{\r\n        cash: contractedPrice - currentPrice,\r\n        annualInterestRate: riskFreeRate,\r\n        timeInYears \r\n    }], compoundType) * contractSize\r\n    \r\n    // return pv([(contractedPrice - currentPrice)], [riskFreeRate], timeInYears, compoundType) * contractSize;\r\n}\r\n\r\nfunction minVarianceHedgeRatio(correlation: number, stdDevSpotPrice: number, stdDevFuturesPrice: number) {\r\n    return correlation * (stdDevSpotPrice/stdDevFuturesPrice);\r\n}\r\n\r\nfunction optimalNumFutures(ratio: number, plannedQuantity: number, contractQuantity: number) {\r\n    return ratio * (plannedQuantity/contractQuantity);\r\n}\r\n\r\nfunction duration(cashFlows: CashFlow[], compoundFrequency: Frequency) {\r\n    return cashFlows.reduce((pv: number, cf: CashFlow) => {\r\n        \r\n        const adjustedInterestRate = cf.annualInterestRate * adjFactor[compoundFrequency];\r\n        const adjustedTime = cf.timeInYears * adjFactor[compoundFrequency];\r\n\r\n        const df = compoundFrequency === \"continuous\" ? \r\n                        Math.exp(-1 * adjustedInterestRate * adjustedTime) : \r\n                        Math.pow(1/(1+adjustedInterestRate), adjustedTime);\r\n\r\n        return pv + adjustedTime * (cf.cash * df);\r\n    }, 0) / pv(cashFlows, compoundFrequency);\r\n}\r\n\r\n/**\r\n * \r\n * @param durationIssue \r\n * @param durationHedge \r\n * @param facevalue SHOULD BE PV of bond payments (i.e. current price)\r\n * @param hedgeValue SHOULD BE PV of futures (i.e. current price)\r\n * @returns \r\n */\r\nfunction durationBasedHedgeRatio(durationIssue: number, durationHedge: number, facevalue: number, hedgeValue: number) {\r\n    return (facevalue/hedgeValue) * (durationIssue/durationHedge); \r\n}\r\n\r\n/**\r\n * Generate cf with constant yield\r\n * @param couponRate \r\n * @param facevalue \r\n * @param nPeriods \r\n * @returns \r\n */\r\nfunction bondCf(couponRate: number, faceValue: number, timeInYearsTillMaturity: number, couponFrequency: Frequency, yield: number) {\r\n    const coupons = Array(timeInYearsTillMaturity * adjFactor[couponFrequency])\r\n    .fill(0)\r\n    .map<CashFlow>((_, idx) => ({\r\n        cash: couponRate / adjFactor[couponFrequency] * faceValue,\r\n        timeInYears: (idx + 1) / adjFactor[couponFrequency],\r\n        annualInterestRate: yield,\r\n    }));\r\n\r\n    coupons[coupons.length - 1].cash += faceValue;\r\n\r\n    return coupons;\r\n}\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}